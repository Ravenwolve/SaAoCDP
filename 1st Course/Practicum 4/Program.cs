using System;

namespace P1_10 {
    internal class Program {
        static bool is_it_a_simple(int n) {//Метод, проверяющий, является ли число простым (да-да, решил сделать функцию, так как код громоздки будет)
            for (int s = 2; s*s <= n; s++) //Перебор всех делителей от 2 до корня из N
            {
                if (n % s == 0)
                    return false;
            }
            return true;
        }
        static void Main(string[] args) {
            Console.Write("Алгоритм: найти число, которое является суммой наибольшего и наименьшего простого множителя заданного числа.\nВведите число N: ");
            int N = int.Parse(Console.ReadLine()), N_sum_of_sim_divs = 0;
            if (is_it_a_simple(N)) // Если число само по себе простое
                N_sum_of_sim_divs += N; // То прибаляем его же как наибольший множитель, не заходя в цикл. Если надо, можно удвоить его, так как он наименьший и наибольший одновременно
            else for (int d = 2, last = N; d*d <= last; d++) //Начинаем искать делители (простые), начиная с 2 и до фактически корня из last, который в начале просто корень из N
            {
                if (is_it_a_simple(d) && last % d == 0) //Сначала проверяем, является ли делителем простым, а затем проверяем, является ли он вообще делителем нашего числа
                {
                    if (N_sum_of_sim_divs == 0) //Если младший делитель ещё не был найден, то прибавляем его к заранее приготовленной переменной суммы
                        N_sum_of_sim_divs += d;
                    last /= d; //Делим значение конца промежутка на найденный простой делитель
                    if (is_it_a_simple(last)) //Проверяем, является ли полученное значение простым числом (он уже является делителем)
                    {
                        N_sum_of_sim_divs += last; //Если это простое число, то оно уже является априори наибольшим простым делителем (если исходное число не простое)
                        break; //Выход из цикла в том случае, если всё, что нужно, уже найдено
                    }
                    d--; //Это чтобы сохранить текущее значение делителя. Понижаем делитель на 1, так как на следующей итерации он возрастёт на 1.
                }//Зачем так делать? Потому что алгоритм не просто бегает по промежутку, а "рубит" его. Это если, допустим, один простой делитель и он же наименьший и набольший. Можно убрать
            }
            Console.WriteLine("Для числа {0} сумма его наибольшего и наименьшего простых множителей равна {1}.", N, N_sum_of_sim_divs);
        }
    }
}
